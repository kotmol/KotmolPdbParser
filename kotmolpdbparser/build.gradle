apply plugin: 'java-library'
java {
    sourceCompatibility = JavaVersion.VERSION_1_8
    targetCompatibility = JavaVersion.VERSION_1_8
    withSourcesJar()
}

apply plugin: 'org.jetbrains.kotlin.jvm'
compileKotlin {
    kotlinOptions {
        jvmTarget = '1.8'
        freeCompilerArgs = [
                '-progressive',
                '-Xjvm-default=enable',
        ]
    }
}

dependencies {
    api deps.kotlinStdLib

    testImplementation deps.junit
    testImplementation deps.jupiter

}

/*
 *  Copyright 2020 James Andreas
 *  Licensed under the Apache License, Version 2.0 (the "License");
 *  you may not use this file except in compliance with the License.
 *  You may obtain a copy of the License at
 *       http://www.apache.org/licenses/LICENSE-2.0
 *  Unless required by applicable law or agreed to in writing, software
 *  distributed under the License is distributed on an "AS IS" BASIS,
 *  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 *  See the License for the specific language governing permissions and
 *  limitations under the License
 */

// credit: jakewharton/Picnic
//   for documentation and maven publishing structure

apply plugin: 'org.jetbrains.dokka'
def dokkaDir = "$buildDir/dokka"
dokka {
    outputFormat = 'html'
    outputDirectory = dokkaDir
}
def dokkaJarTaskProvider = tasks.register('dokkaJar', Jar) { task ->
    task.archiveClassifier.set('javadoc')
    task.from(dokkaDir)
    task.dependsOn('dokka')
}

def javadocJarTaskProvider = tasks.register('javadocJar', org.jetbrains.dokka.gradle.DokkaTask) { task ->
    task.outputFormat = 'javadoc'
    task.outputDirectory = "$buildDir/javadoc"
}
tasks.named('assemble').configure {
    it.dependsOn(javadocJarTaskProvider)
}

def isReleaseBuild = !version.endsWith('-SNAPSHOT')

apply plugin: 'maven-publish'

publishing {
    publications {
        release(MavenPublication) {
            from components.java

            // TODO how to provide this asynchronously?
            // TODO how to provide this through the component?
            artifact dokkaJarTaskProvider.get()

            pom {
                name = 'KotmolPdbParser'
                description = 'Protein DataBase parser in Kotlin.'
                url = 'https://github.com/kotmol/KotmolPdbParser'
                licenses {
                    license {
                        name = 'The Apache License, Version 2.0'
                        url = 'http://www.apache.org/licenses/LICENSE-2.0.txt'
                    }
                }
                developers {
                    developer {
                        id = 'jimandreas'
                        name = 'Jim Andreas'
                    }
                }
                scm {
                    connection = 'scm:git:git://github.com/kotmol/KotmolPdbParser.git'
                    developerConnection = 'scm:git:ssh://git@github.com/kotmol/KotmolPdbParser.git'
                    url = 'https://github.com/kotmol/KotmolPdbParser'
                }
            }
        }
    }
    repositories {
        maven {
            url = isReleaseBuild
                    ? 'https://oss.sonatype.org/service/local/staging/deploy/maven2/'
                    : 'https://oss.sonatype.org/content/repositories/snapshots/'
            credentials {
                username = project.hasProperty('SONATYPE_NEXUS_USERNAME') ? SONATYPE_NEXUS_USERNAME : ''
                password = project.hasProperty('SONATYPE_NEXUS_PASSWORD') ? SONATYPE_NEXUS_PASSWORD : ''
            }
        }
    }
}

if (isReleaseBuild) {
    apply plugin: 'signing'
    signing {
        required { gradle.taskGraph.hasTask("publish") }
        sign publishing.publications
    }
}

tasks.register('publishSnapshot').configure { task ->
    if (!isReleaseBuild) {
        task.dependsOn(tasks.getByName('publish'))
    }
}

// this solves problems with IDE vs Gradle based testing flows
// https://stackoverflow.com/a/60269625/3853712
test {
    useJUnitPlatform()
    testLogging {
        events "passed", "skipped", "failed"
    }
}

// credit: MarcinMoskala/KotlinDiscreteMathToolkit

tasks.withType(Test) {
    testLogging {
        // set options for log level LIFECYCLE
        events "passed", "skipped", "failed", "standardOut"
        showExceptions true
        exceptionFormat "full"
        showCauses true
        showStackTraces true

        // set options for log level DEBUG and INFO
//        debug {
//            events "started", "passed", "skipped", "failed", "standardOut", "standardError"
//            exceptionFormat "full"
//        }
        info.events = debug.events
        info.exceptionFormat = debug.exceptionFormat

        afterSuite { desc, result ->
            if (!desc.parent) { // will match the outermost suite
                def output = "Results: ${result.resultType} (${result.testCount} tests, ${result.successfulTestCount} successes, ${result.failedTestCount} failures, ${result.skippedTestCount} skipped)"
                def startItem = '|  ', endItem = '  |'
                def repeatLength = startItem.length() + output.length() + endItem.length()
                println('\n' + ('-' * repeatLength) + '\n' + startItem + output + endItem + '\n' + ('-' * repeatLength))
            }
        }
    }
}